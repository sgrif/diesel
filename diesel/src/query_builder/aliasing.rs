use backend::Backend;
use expression::{AppearsOnTable, Expression, NonAggregate, SelectableExpression};
use query_builder::{AstPass, QueryFragment, SelectStatement};
use query_source::joins::{Inner, Join, JoinOn, LeftOuter};
use query_source::{AppearsInFromClause, Column, Never, Once, QuerySource};
use result::QueryResult;

#[derive(Debug, Clone, Copy, QueryId)]
/// Represents an aliased query.
///
/// This struct is constructed by calling [`.aliased`] on a query. The alias
/// should be generated by using [`diesel_define_alias!`].
///
/// [`.aliased`]: ../query_dsl/trait.QueryDsl.html#method.aliased
/// [`diesel_define_alias!`]: ../macro.diesel_define_alias.html
///
/// A struct of this type represents the SQL `table_name alias` for plain
/// tables, and `(SUBSELECT) alias` for aliased subselects.
pub struct Aliased<Query, Alias> {
    query: Query,
    alias: Alias,
}

impl<Query, Alias> Aliased<Query, Alias> {
    pub(crate) fn new(query: Query, alias: Alias) -> Self {
        Self { query, alias }
    }
}

impl<Query, Alias> Aliased<Query, Alias>
where
    Self: QuerySource,
{
    /// Retrieve the select clause of this aliased query as a tuple.
    ///
    /// The returned tuple will be suitable for use in any part of your query.
    /// Any expressions that are not columns will be automatically given a
    /// unique name.
    /// This method is the only way to reference columns from an aliased table.
    /// There is no way to retrieve them by name.
    ///
    /// # Example
    ///
    /// ```
    /// # #[macro_use] extern crate diesel;
    /// # include!("../doctest_setup.rs");
    /// #
    /// # fn main() {
    /// diesel_define_alias!(users2);
    ///
    /// let u2 = users::table.aliased(users2);
    /// let (u2_id, ..) = u2.selection();
    ///
    /// # #[cfg(feature = "postgres")]
    /// # let expected_sql = r#""users2"."id""#;
    /// # #[cfg(not(feature = "postgres"))]
    /// let expected_sql = "`users2`.`id`";
    /// let actual_sql = debug_query::<DB, _>(&u2_id).to_string();
    /// assert_eq!(expected_sql, actual_sql);
    /// # }
    pub fn selection(&self) -> <Self as QuerySource>::DefaultSelection {
        self.default_selection()
    }
}

impl<Query, Alias> QuerySource for Aliased<Query, Alias>
where
    Query: QuerySource,
    Query::DefaultSelection: FromAliasedTable<Alias>,
    <Query::DefaultSelection as FromAliasedTable<Alias>>::Output: SelectableExpression<Self>,
    Alias: Copy,
{
    type FromClause = Aliased<Query::FromClause, Alias>;

    type DefaultSelection = <Query::DefaultSelection as FromAliasedTable<Alias>>::Output;

    fn from_clause(&self) -> Self::FromClause {
        Aliased::new(self.query.from_clause(), self.alias)
    }

    fn default_selection(&self) -> Self::DefaultSelection {
        self.query
            .default_selection()
            .from_aliased_table(self.alias)
    }
}

impl<Query, Alias, DB> QueryFragment<DB> for Aliased<Query, Alias>
where
    DB: Backend,
    Query: QueryFragment<DB>,
    Alias: QueryFragment<DB>,
{
    fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
        self.query.walk_ast(out.reborrow())?;
        out.push_sql(" ");
        self.alias.walk_ast(out.reborrow())?;
        Ok(())
    }
}

pub trait FromAliasedTable<Alias> {
    type Output;

    fn from_aliased_table(self, alias: Alias) -> Self::Output;
}

impl<Col: Column, Alias> FromAliasedTable<Alias> for Col {
    type Output = ColumnFromAliasedTable<Self, Alias>;

    fn from_aliased_table(self, alias: Alias) -> Self::Output {
        ColumnFromAliasedTable::new(self, alias)
    }
}

macro_rules! tuple_impls {
    ($(
        $Size:tt {$(
            ($idx:tt) -> $T:ident, $ST:ident, $TT:ident,
        )+}
    )+) => {$(
        impl<$($T,)+ Alias> FromAliasedTable<Alias> for ($($T,)+)
        where
            $($T: FromAliasedTable<Alias>,)+
            Alias: Copy,
        {
            type Output = ($($T::Output,)+);

            fn from_aliased_table(self, alias: Alias) -> Self::Output {
                ($(self.$idx.from_aliased_table(alias),)+)
            }
        }
    )*};
}

__diesel_for_each_tuple!(tuple_impls);

#[derive(Debug, Clone, Copy, QueryId)]
pub struct ColumnFromAliasedTable<Col, Alias> {
    column: Col,
    alias: Alias,
}

impl<Col, Alias> ColumnFromAliasedTable<Col, Alias> {
    fn new(column: Col, alias: Alias) -> Self {
        Self { column, alias }
    }
}

impl<Col, Query, Alias> SelectableExpression<Aliased<Query, Alias>>
    for ColumnFromAliasedTable<Col, Alias>
where
    Self: AppearsOnTable<Aliased<Query, Alias>>,
    Col: SelectableExpression<Query>,
{
}

impl<Col, Query, Alias> AppearsOnTable<Query> for ColumnFromAliasedTable<Col, Alias>
where
    Self: Expression,
    Query: AppearsInFromClause<Alias, Count = Once>,
{
}

impl<Left, Right, Col, Alias> SelectableExpression<Join<Left, Right, LeftOuter>>
    for ColumnFromAliasedTable<Col, Alias>
where
    Self: AppearsOnTable<Join<Left, Right, LeftOuter>>,
    Left: AppearsInFromClause<Alias, Count = Once>,
    Right: AppearsInFromClause<Alias, Count = Never>,
{
}

impl<Left, Right, Col, Alias> SelectableExpression<Join<Left, Right, Inner>>
    for ColumnFromAliasedTable<Col, Alias>
where
    Self: AppearsOnTable<Join<Left, Right, Inner>>,
    Join<Left, Right, Inner>: AppearsInFromClause<Alias, Count = Once>,
{
}

// FIXME: Remove this when overlapping marker traits are stable
impl<Join, On, Col, Alias> SelectableExpression<JoinOn<Join, On>>
    for ColumnFromAliasedTable<Col, Alias>
where
    Self: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>,
{
}

// FIXME: Remove this when overlapping marker traits are stable
impl<From, Col, Alias> SelectableExpression<SelectStatement<From>>
    for ColumnFromAliasedTable<Col, Alias>
where
    Self: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>,
{
}

impl<Col, Alias> Expression for ColumnFromAliasedTable<Col, Alias>
where
    Col: Expression,
{
    type SqlType = Col::SqlType;
}

impl<Col, Alias> NonAggregate for ColumnFromAliasedTable<Col, Alias>
where
    Col: NonAggregate,
{
}

impl<Col, Alias, DB> QueryFragment<DB> for ColumnFromAliasedTable<Col, Alias>
where
    DB: Backend,
    Col: Column,
    Alias: QueryFragment<DB>,
{
    fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
        self.alias.walk_ast(out.reborrow())?;
        out.push_sql(".");
        out.push_identifier(Col::NAME)?;
        Ok(())
    }
}

impl<Query, Alias, T> AppearsInFromClause<T> for Aliased<Query, Alias>
where
    Alias: AppearsInFromClause<T>,
{
    type Count = Alias::Count;
}
